#summary Project outline

= Project Plans =

==Project Stages==
This project involves two stages. First is the making of the assembler. Second is the probing of various detailed features of the GF1xx architectures.

===Assembler===
  # *Started, 1/3 complete*: Determining the format of assembly source code. Most likely the output format of cuobjdump will be followed so that its output can be directly assembled by the assembler. However, there exists the possibility that a PTX-like format may also be supported.
  # *Started, 1/20 complete*: Probing Fermi's opcode format
  # Writing the assembler
  # Completing the assembler by adding support for directly producing .cubin files, which can then be used by CUDA programmes and nvcc.

===Microbenchmarking===
====Instruction-related====
  * Instruction cache
    * Cache associativity
    * Cacheline size
    * Prefetch pattern
    * Effects of large jumping
  * Warp scheduling
    * ILP depth: How many unfinished instructions could the scheduler deal with before stalling?
    * Scheduling behaviour: depth-first? width-first? Or a mix or the two?
    * Divergence behaviour
    * Processing Unit Group characteristics
    * Is ILP considered when picking warps on CC2.1 devices?
  * Instruction latencies
  * Effects of larger-than-32-bit accesses
  * Register bank conflict

====Memory-related====
  * Latency
    * Various types of caches and memories
    * Various modifiers
    * Memoryfence
    * Atomic
  * Cache associativity
  * Cache eviction protocol
  * Cache consistency across kernel launches, context switches
  * Cache sharing. (L2)
  * Specific types
    * Constant memory
    * Texture memory
    * Local memory
    * Global memory
    * Shared memory

====Others====
  * Kernel launch overhead
  * Block scheduling overhead
  * Block scheduling pattern
----
===Sidelines===
==== cuobjdump output processor ====
Recovers correct opcode binary digits from the output of cuobjdump.
Usage:
<pre>
cuobjdump -sass(or something else) file.cubin>in.txt
cuprocess in.txt out.txt
</pre>

The program makes heavy assumption about the input file and produces messy stuff for non-instruction lines, though that should not matter as long as you follow the usage above.

[http://code.google.com/p/asfermi/source/browse/trunk/utilities/cuprocess.cpp Source]

==== cubin binary editor ====
A very simple binary mode editor I made for myself. Written in C#.NET. Contains binary for Windows with .NET Framework 3.5 or higher.

This program displays opcode in binary mode and the least significant bit is displayed first.

Usage: Open program. Click Browse, choose file. Click Load. Scroll to the instruction location you want(You need another binary editor to locate the instruction first). If your instruction location has an offset that is a multiple of 4 instead of 8, enter 4 into the num box and click Set Offset. Do editing as you normally would with a binary editor then click Write Back.

Ctrl+Up = go to the box above
Ctrl+Down = go to box below

Now supports command line arguments

<pre>CUBINEditor inputfile offset</pre>

Note: May contain bug, as most of it was written while I was half-asleep. This program is written with minimal complexity so you could expect crashes whenever you do something I did not expect.
[http://code.google.com/p/asfermi/downloads/detail?name=CUBINEditor%20v2.zip Download]