#summary Program design of the Fermi assembler

<wiki:toc max_depth="2" />

=Basic types and global variables=
{{{
//current states
int (*cs_lparser)(Line line); //Current line parser
int (*cs_iparser)(Instruction instruction); //Current instruction parser
int (*cs_dparser)(Directive directive); //Current directive parser
/*function pointers are used so that different parsers can be used when needed, 
under the command of specific directives. For example, directives can indicate 
whether the following section of code is in cuobjdump format or in PTX-like format.

The line parser removes unnecessary white-space identifies whether a line 
contains directive/comment. If there is a not-yet-closed comment block, it 
searches for "*/". If not found the parsing is over. If found, the
cs_incomment is set to false. The line parser then removes unnecessary white-space 
and comment, and checks for the existence of the directive identifier "#" in the
first character. If it is found, the parser will build a Directive object and 
ask the Directive object to parse itself. If it is not found, the parser looks for 
instruction delimiter ";" and breaks the filtered string into tokens. It then 
build up a Instruction object for each token obtained and asks the Instruction 
object to parse itself.

*/

int cs_ln; //current line number
list<Directive> cs_directives; //list of directives encountered so far
bool cs_incomment; //whether there is an not-yet-closed comment block

struct Line
{
    char* line_content;
    int line_number;
    void Parse()
    {
        cs_lparser(self);
    }
};
struct Directive:: public Line
{
    int directive_type;
    int* directive_content; //array of pointers specific to each directive_type
    void Parse()
    {
        cs_dparser(self);
    }
};
struct Instruction:: public Line
{
    char *instruction_string;
    int instruction_type;
    char *instruction_bytes;
    int *instruction_content; //array of pointers to content specific to each instruction_type. 
                              //Usually include operator1, operator2 or operator3
    void Parse()
    {
        cs_iparser(self);
    }
};
}}}


=Stages=
==Source file processing==
  * Read source file
  * Split source file into char`*``*`, with each char`*` containing one line
  * foreach( char`*` in char`*``*`)  {  parse(char`*`) }
==Parsing==
  * Ignore if this line is inside a multi-line comment section
  * Remove unnecessary white-space and in-line comment