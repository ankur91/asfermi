#summary opcodes for integer operation instructions

Note: round brackets, instead of square brackets, are used to represent an optional component. This is to avoid confusion with memory operands which are surrounded by square brackets.

Also, [Opcode#imme immea] and [SourceFormat#Composite_operand composite operand] may be mentioned in the parts below. Please visit these two links for more information regarding their meaning.

=== Integer Instructions ===
<wiki:toc>
==== IADD ====
Instruction usage:
{{{
IADD(.SAT)(.X) reg0, (-)reg1, (-)composite operand;
}}}
If the composite operand is an immediate value, it cannot be longer than 20 bits (cannot be negative).

Also note that the when the negative operator is used on both reg1 and reg3, a .PO modifier would appear in the cubin instead. What .PO does has not been tested.

Template opcode:
{{{
1100 000000 1110 000000 000000 0000000000000000000000 0000000000 010010
        mod        reg0   reg1                  immea
}}}

||mod 0:1||meaning||
||00     ||default||
||10     ||-reg3  ||
||01     ||-reg1  ||
||11     ||.PO    ||

||mod bit||meaning   ||
||3      ||0: default||
||       ||1: .X     ||
||4      ||0: default||
||       ||1: .SAT   ||


----
==== IADD32I ====
Template opcode
{{{
0100 000000 1110 000000 000000 00000000000000000000000000000000 0 10000
        mod        reg0   reg1                           0xabcd m
}}}
||mod bit||meaning   ||
||3      ||0: default||
||       ||1: .X     ||
||4      ||0: default||
||       ||1: .SAT   ||

||m 0  ||meaning||
||0    ||default||
||1    ||reg0.CC||

----
==== IMUL ====
Instruction Usage
{{{
IMUL(.U32/S32)(.U32/.S32)(.HI) reg0(.CC), reg1, composite operand;
}}}

Template opcode:
{{{
1100 010100 1110 000000 000000 0000000000000000000000 0000000000 001010
        mod        reg0   reg1                  immea       mod2
}}}
||mod bit|| meaning||
||2      ||0: .U32, first modifier||
||       ||1: .S32, first modifier||
||3      ||0: .LO default         ||
||       ||1: .HI                 ||
||4      ||0: .U32, second modifier||
||       ||1: .S32, second modifier||

||mod2 9||meaning||
||0     ||default||
||1     ||reg0.CC||


----
==== IMUL32I ====
Instruction usage:
{{{
IMUL32I(.U32/S32)(.U32/.S32)(.HI) reg0(.CC), reg1, composite operand;
}}}
Template opcode:
{{{
0100 010100 1110 000000 000000 00000000000000000000000000000000    0 01000
        mod        reg0   reg1                           0xabcd mod2
}}}

||mod bit|| meaning||
||2      ||0: .U32, first modifier||
||       ||1: .S32, first modifier||
||3      ||0: .LO default         ||
||       ||1: .HI                 ||
||4      ||0: .U32, second modifier||
||       ||1: .S32, second modifier||

||mod2 0||meaning||
||0     ||default||
||1     ||reg0.CC||

----
==== IMAD ====
Instruction usage:
{{{
IMAD(.U32/S32)(.U32/.S32)(.HI)(.SAT) reg0(.CC), (-)reg1, composite operand, (-)reg3;
}}}
Or,
{{{
IMAD(.U32/S32)(.U32/.S32)(.HI)(.SAT) reg0(.CC), (-)reg1, (-)reg2, composite operand;
}}}
Note that the when the negative operator is used on both reg1 and reg3, a .PO modifier would appear in the cubin instead. What .PO does has not been tested.

Both the third and the fourth operand can be a composite operand, but the other one must be a register.

Template opcode:
{{{
1100 010100 1110 000000 000000 0000000000000000000000 0 000000  000 000100
        mod        reg0   reg1                  immea m   reg3 mod2
}}}

||mod 0:1||meaning||
||00     ||default||
||10     ||-reg3  ||
||01     ||-reg1  ||
||11     ||.PO    ||

||2      ||0: .U32, first modifier||
||       ||1: .S32, first modifier||
||3      ||0: .LO default         ||
||       ||1: .HI                 ||
||4      ||0: .U32, second modifier||
||       ||1: .S32, second modifier||

||m 0   ||meaning||
||0     ||default||
||1     ||reg0.CC||

||mod2 1|| meaning ||
||0     ||default||
||1     ||.SAT   ||


----
==== ISCADD ====
Instruction usage:
{{{
ISCADD reg0, reg1, composite operand, int1;
}}}
reg0 = reg1<<int1 + reg0;

Note that int1 must be less than 32.

Template opcode:
{{{
1100 0 00000 1110 000000 000000 0000000000000000000000 0000000000 000010
        int1        reg0   reg1                  immea       mod2
}}}

||mod2 1:2||meaning   ||
||00      ||0: default||
||01      ||1: -reg1  ||
||10      ||0: -int0  ||
||11      ||1: .PO    ||

||mod2 9||meaning||
||0     ||default||
||1     ||reg0.CC||


----
==== ISETP ====
Instruction usage:
{{{
ISETP.CompOp(.U32)(.LogicOp) p, |p, reg0, composite operand, opp;
}}}
Template opcode:
{{{
1100 010000 1110 111 000 000000 0000000000000000000000 0 1110 000000 11000
        mod       |p   p   reg0                  immea    opp   mod2
}}}

||mod 4||meaning||
||0    ||.U32   ||
||1    ||default||

||mod2 0:3 value||`.CompOp`||
||1             ||.LT||
||2             ||.EQ||
||3             ||.LE||
||4             ||.GT||
||5             ||.NE||
||6             ||.GE||

||mod2 4:5 value ||`.LogicOp`||
||0              ||.AND||
||1              ||.OR||
||2              ||.XOR||

----
==== ICMP ====
Instruction usage:
{{{
ICMP.CompOp(.U32) reg0, reg1, composite operand, reg3
}}}
reg0 = (reg3 `CompOp` 0)? reg1 : composite operand; The .U32 modifier indicates the type of reg3. reg3 is assumed to be S32 when .U32 is not specified.

Template opcode
{{{
1100 010000 1110 000000 000000 0000000000000000000000 0 000000  000 001100
        mod        reg0   reg1                  immea     reg3 mod2
}}}
||mod 4||meaning||
||0    ||.U32   ||
||1    ||default(.s32)||

||mod2 0:2 value||`.CompOp`||
||1             ||.LT||
||2             ||.EQ||
||3             ||.LE||
||4             ||.GT||
||5             ||.NE||
||6             ||.GE||