#summary This page describes the opcode format of fermi

Note: information here is not organised. Many parts may be unclear and confusing. Information may be inaccurate as so far I only experimented with MOV.

= Opcode Information =
Currently 2 types of opcodes found: 4-byte and 8-byte

----
== 8-byte ==

<pre>
/`*`0018`*`/     /`*`0xfc035de21bffffff`*`/ 	MOV32I R13, -0x1;
0100 011110 1110 101100 000000 11111111111111111111111111111111 0  11000
na   mod    pr   re1    re0    addr                             cc nb
====na nb====
These two bit fields specify the instruction name. Invalid bits result in invalid opcode.

====re1 re2====
re1 to 111111 gives MOV32I RZ, -0x1; => proving 111111 is indeed RZ
changing the re1 from 111111 to 111110 gives R62 => correctly coded register
changing re0 to 111111 gives no diff from cuobjdump => cuobjdump does not use this reg for mov32i

==== mod ====
mod0: 1: .S to mov32i
mod1: 1: .X to lop32i
mod2: 0: .AND; 1: .OR; all added to lop32i
mod3: 1: .XOR
mod2-3: 11: .PASS_B to lop32i
mod4: no effect seen so far
mod5: 1: ~on second operator of lop32i

==== pr ====
pr0-2: predicate number, little endian, from 0-6
when pr3 is set to 1, means negate predicate
however, when set to negate, doesn't use, P7(1111), the predicate becomes @!pt. what is pt?
When does not negate, P7 means no predicate used

====cc====
has effect on first operator for some instructions

====random info====
when last 6 bits become:
		000000: IMAD32I.U32.U32 R0, -R0, -0x1, R0;
		000100: FFMA32I R0, -R0, -0x1, R0;
		001000: IMUL32I.U32.U32 R0, R0, -0x1;
		001100: FMUL32I.FMA2 R0, R0, -0x1;
		010000: IADD32I R0, -R0, -0x1;
		010100: FADD32I R0, -R0, -0x1;
		011000: MOV32I R0, -0x1, 0x0;
		011100: LOP32I.AND R0, ~R0, -0x1;
		111100: LOP32I.AND R0.CC, ~R0, -0x1;
		101000: IMUL32I.U32.U32 R0.CC, R0, -0x1;
</pre>

== 4-byte ==

==Some code==
Previously I was thinking even data type would have an effect on the mov instruction as the normal mov I get is named MOV32I. I thought that 'I' at the end had some thing to do with integers. Apparently I was wrong. Now I think it means 'immediate'.
{{{
	.version 2.3
	.target sm_21
.global.u32 gu;
.global.s32 gs;
.global.f32 gf;
.entry kernel1()
{
	.shared .align 4 .b8 localmem[128];
	.reg .u32 ru;
	.reg .s32 rs;
	.reg .f32 rf;
	mov.u32 ru, 0xffffffff;
	mov.s32 rs, 0xfffffffe;
	mov.f32 rf, 0Ffffffffd;
	st.shared.u32 [localmem+0], ru;
	st.shared.s32 [localmem+4], rs;
	st.shared.f32 [localmem+8], rf;
	st.global.u32 [gu], ru;
	st.global.s32 [gs], rs;
	st.global.f32 [gf], rf;
	exit;
}

/*0008*/     /*0x00001de440000000*/ 	NOP CC.T;		0010011110111000000000000000000000000000000000000000000000000010
/*0000*/     /*0x00005de428004404*/ 	MOV R1, c [0x1] [0x100];0010011110111010000000000000000000100000001000100000000000010100
/*0018*/     /*0x00001de428007800*/ 	MOV R0, c [0xe] [0x0];	0010011110111000000000000000000000000000000111100000000000010100
/*0030*/     /*0x10009de428007800*/ 	MOV R2, c [0xe] [0x4];	0010011110111001000000000000100000000000000111100000000000010100
/*0040*/     /*0x20001de428007800*/ 	MOV R0, c [0xe] [0x8];	0010011110111000000000000000010000000000000111100000000000010100
/*0010*/     /*0xfc00dde21bffffff*/ 	MOV32I R3, -0x1;	0100011110111011000000000011111111111111111111111111111111011000	mov.u32 ru, 0xffffffff;
/*0020*/     /*0xf8011de21bffffff*/ 	MOV32I R4, -0x2;	0100011110111000100000000001111111111111111111111111111111011000	mov.s32 rs, 0xfffffffe;
/*0038*/     /*0xf4015de21bffffff*/ 	MOV32I R5, -0x3;	0100011110111010100000000010111111111111111111111111111111011000	mov.f32 rf, 0Ffffffffd;
/*0048*/     /*0x03f0dc85c9000000*/ 	STS [0x0], R3;		1010000100111011000011111100000000000000000000000000000010010011	st.shared.u32 [localmem+0], ru;
/*0058*/     /*0x13f11c85c9000000*/ 	STS [0x4], R4;		1010000100111000100011111100100000000000000000000000000010010011	st.shared.s32 [localmem+4], rs;
/*0060*/     /*0x23f15c85c9000000*/ 	STS [0x8], R5;		1010000100111010100011111100010000000000000000000000000010010011	st.shared.f32 [localmem+8], rf;
/*0068*/     /*0x00015c8590000000*/ 	ST [R0], R5;		1010000100111010100000000000000000000000000000000000000000001001	st.global.u32 [gu], ru;
/*0028*/     /*0x0000dc8590000000*/ 	ST [R0], R3;		1010000100111011000000000000000000000000000000000000000000001001	st.global.s32 [gs], rs;
/*0050*/     /*0x00211c8590000000*/ 	ST [R2], R4;		1010000100111000100001000000000000000000000000000000000000001001	st.global.f32 [gf], rf;
/*0070*/     /*0x00001de780000000*/ 	EXIT;			1110011110111000000000000000000000000000000000000000000000000001	exit;
}}}