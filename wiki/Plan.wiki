#summary Project outline

= Project Plans =

==Project Stages==
This project involves two stages. First is the making of the assembler. Second is the probing of various detailed features of the GF1xx architectures.

===Assembler===
  # Determining the format of assembly source code. (1/2 complete)
  # Probing Fermi's opcode (1/4 complete)
   # Instruction names (Done)
   # General opcode format (Done)
   # Specific information for each instruction opcode
    # MOV, LD, ST, ADD, EXIT
    # ...
  # Probing NVIDIA's custom sections in cubins
  # Writing the assembler
----
*Time line*
  * By 16/6/2011: in-line comment, constant operands
  * By 30/6/2011: produce cubin independently (kernel info section, constant symbol, shared memory, device function section, directives to mark kernels)
  * By 15/7/2011: support all 4-byte instructions as well as their 8-byte counterparts.
<wiki:comment>
  by 20/7/2011: probe instruction latencies for important instructions
</wiki:comment>
----

===Microbenchmarking===
====Instruction-related====
  * Instruction cache
    * Cache associativity
    * Cacheline size
    * Prefetch pattern
    * Effects of large jumping
  * Warp scheduling
    * ILP depth: How many unfinished instructions could the scheduler deal with before stalling?
    * Scheduling behaviour: depth-first? width-first? Or a mix or the two?
    * Divergence behaviour
    * Processing Unit Group characteristics
    * Is ILP considered when picking warps on CC2.1 devices?
  * Instruction latencies
  * Effects of larger-than-32-bit accesses
  * Register bank conflict

====Memory-related====
  * Latency
    * Various types of caches and memories
    * Various modifiers
    * Memoryfence
    * Atomic
  * Cache associativity
  * Cache eviction protocol
  * Cache consistency across kernel launches, context switches
  * Cache sharing. (L2)
  * Specific types
    * Constant memory
    * Texture memory
    * Local memory
    * Global memory
    * Shared memory

====Others====
  * Kernel launch overhead
  * Block scheduling overhead
  * Block scheduling pattern
----
===Sidelines===
==== Utilities ====
See [Utilities].


<wiki:comment>
build a utility that permute selected bits. Each instance of permutation gets injected into an individual file. Generate as many files as there are instances of the permutation and test run all the files to confirm the validity of the instructions. Take down the code of the permutation for the cases that are validly executed. Generate a .txt table with all the permuted code and a string to represent their validity. Then sort them according to specific bits to view their validity. Sort them using excel or perhaps build another utility to sort and identify the modifiers.
1. say 10 bits to be permuted
2. 1024 cubins, 1024 runs
3. A file showing the permuted binary digits of all files and their corresponding validity
4. Sort the file in 3 to find out valid independent and compound modifier bits.
5. Probe the modifier names using cuobjdump.
</wiki:comment>