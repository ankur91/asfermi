#summary Program design of the Fermi assembler

<wiki:toc/>


----
== Organisation ==
=== General structure ===
Line parser -> (Instruction parser, Directive Parser)

The Line parser picks a line, does certain basic processing, makes a judgement about whether this line is a directive or an instruction, and then
  * Asks the directive parser to parse the processed part of the line, if the line is a directive, or
  * Asks the instruction parser to parse the processed part of the line, if the line is an instruction.
=== Extensions ===
----
==Basic types and global variables==
{{{

//Global states
stack<int *(Line line)> pr_lparser;               //Stack of previously used parser
stack<int *(Instruction instruction)> pr_iparser;
stack<int *(Directive directive)> pr_dparser;

list<Lparser> lparsers;        //List of parsers loaded at initialization
list<Iparser> iparsers;
list<Dparser> dparsers;


//current states
int cs_ln;                       //current line number
list<Directive> cs_directives;   //list of directives encountered so far
list<int[]> cs_labels;           //list of labels encountered so far
bool cs_incomment;               //whether there is an not-yet-closed comment block

int (*cs_lparser)(Line line);                //Current line parser
int (*cs_iparser)(Instruction instruction);  //Current instruction parser
int (*cs_dparser)(Directive directive);      //Current directive parser

/*function pointers are used so that different parsers can be used when needed, 
under the command of specific directives. For example, directives can indicate 
whether the following section of code is in cuobjdump format or in PTX-like format.

The default line parser removes unnecessary white-space and identifies whether a 
line contains directive/comment. If there is a not-yet-closed comment block, it 
searches for "star/". If not found, the parsing would be over. If found, the
cs_incomment is set to false. The line parser then removes unnecessary white-space 
and comment, and checks for the existence of the directive identifier "!" in the
first character. If it is found, the parser will build a Directive object and 
ask the Directive object to parse itself. If it is not found, the parser looks for 
instruction delimiter ";" and breaks the filtered string into tokens. It then 
builds up an Instruction object for each token obtained and asks the Instruction 
object to parse itself.

However, line parsers can be changed. The general behaviour: The next line is 
picked. The current line parser is used to parse this line. While default line
parser often generates Instruction/Directive objects, custom line parsers need not 
to, meaning that a line could be of a type other than directive/instruction. Thus 
great flexibility of the source code is provided.

*/


struct Line
{
    char* line_content;
    int line_number;
    void Parse()
    {
        cs_lparser(self);
    }
};
struct Directive:: public Line
{
    int directive_type;
    int* directive_content; //array of pointers specific to each directive_type
    void Parse()
    {
        cs_dparser(self);
    }
};
struct Instruction:: public Line
{
    char *instruction_string;
    int instruction_type;
    char *instruction_bytes;
    int *instruction_content; //array of pointers to content specific to each instruction_type. 
                              //Usually include operator1, operator2 or operator3
    void Parse()
    {
        cs_iparser(self);
    }
};
struct Parser
{
    char* Name;
};
struct Lparser:: public Parser
{
    int Function(Line line)
    {
    }
};
struct Iparser:: public Parser
{
    int Function(Instruction instruction)
    {
    }
};
struct Dparser:: public Parser
{
    int Function(Directive directive)
    {
    }
};



void Set_lparser(char* name) //same goes for i/d parsers
{
    pr_lparsers.push();
    foreach(Lparser p in lparsers)
    {
        if(p.Name == name)
        {
            cs_lparser=p.Function;
            break;
        }
    }
}
void Set_pr_lparser() //Same goes for i/d parsers
{
    cs_lparser = pr_lparsers.pop();
}
}}}